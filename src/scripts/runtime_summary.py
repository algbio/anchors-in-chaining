import math
import argparse
import subprocess
from constant import *
import time
import csv

RUN_PATH = ''


def save_time(start_time, end_time, path):
    writer = open(path, 'w')
    writer.write("--- %s seconds ---" % (end_time - start_time))
    writer.close()

def parse_reads() -> int:
    # parse reads from file generated by simlord
    # creates individual files for each read
    i = 0
    reads = ''
    with open('data/reads.fastq') as f:
        for j, line in enumerate(f):
            if j % 3 == 0:
                read = next(f)
                reads += read.strip()+'#'
                i += 1
    
    f2 = open('data/reads.txt', 'w')
    f2.write(f">all the reads\n")
    f2.write(reads)
    f2.close()
    return i

def generate_congif_bdbwt_mem(output_file_path, target_file_path, query_file_path, k, mode) -> str:
    # generate a text file for bdbwt mem tool
    f2 = open(output_file_path, 'w')
    f2.write(f"Verbosity > 4\n")
    f2.write(f"Text1	> {query_file_path}\n")
    f2.write(f"Index1	> 1\n")
    f2.write(f"Text2	> {target_file_path}\n")
    f2.write(f"Index2	> 1\n")
    f2.write(f"Mode 	> {mode}\n")
    f2.write(f"Depth	> {k}\n")
    f2.write(f"Window 	> {k}\n")
    f2.write("Mergers > 0\n")
    f2.write("BWTThrd > 1\n")
    f2.write("VerbCA  > 0\n")
    f2.write("VerbED > 0\n")
    f2.write("RawChain > 0\n")
    f2.write("strChain > 0\n")
    f2.write("recombAbs > 0\n")
    f2.write("linearRMQ > 0")
    f2.close()

def run_anchoring_algo(mode, read_id, k_value, target_path, query_path, output_path, measure_time=False, config_path=''):
    if os.path.isfile(output_path):
        return
    if config_path != '' and os.path.isfile(config_path):
        return
    print(f'running {mode} for read {read_id}')

    if mode == BDBWT_EXT_MINI or mode == BDBWT_MEM:
        generate_congif_bdbwt_mem(
            config_path, target_path, query_path, k_value, 0 if mode == BDBWT_MEM else 1)
        start_time = time.time()
        subprocess.run(ANCHOR_ALGOS[mode].format(
            config_path, output_path, RUN_PATH), shell=True)
        end_time = time.time()
    elif mode == BR_INDEX_MEM:
        if not os.path.isfile(target_path + '.bri'):
            subprocess.run(R_INDEX_ALGO.format(
                target_path, RUN_PATH), shell=True)
        subprocess.run(R_INDEX_ALGO.format(query_path, RUN_PATH), shell=True)
        start_time = time.time()
        subprocess.run(ANCHOR_ALGOS[mode].format(
            k_value, output_path, target_path+'.bri', query_path+'.bri', RUN_PATH), shell=True)
        end_time = time.time()
    else:
        start_time = time.time()
        subprocess.run(ANCHOR_ALGOS[mode].format(
            k_value, query_path, target_path, output_path, RUN_PATH), shell=True)
        end_time = time.time()
    if measure_time:
        save_time(start_time, end_time,
                  BENCHMARK_ANCHOR_PATH[mode].format(read_id))

def anchors_only(target_path, k_value, read_id='all'):
    read_path = 'data/reads.txt'
    run_anchoring_algo(BDBWT_EXT_MINI, read_id, k_value, target_path, read_path, ANCHOR_PATH[BDBWT_EXT_MINI].format(read_id), True, 'bdbwt-mem/config_all1')
    run_anchoring_algo(BDBWT_MEM, read_id, k_value, target_path, read_path, ANCHOR_PATH[BDBWT_MEM].format(read_id), True, 'bdbwt-mem/config_all2')
    run_anchoring_algo(MUMMER_MEM, read_id, k_value, target_path,
                       read_path, ANCHOR_PATH[MUMMER_MEM].format(read_id), True)
    run_anchoring_algo(MUMMER_MUM, read_id, k_value, target_path,
                       read_path, ANCHOR_PATH[MUMMER_MUM].format(read_id), True)
    run_anchoring_algo(MINIMAP, read_id, k_value, target_path,
                       read_path, ANCHOR_PATH[MINIMAP].format(read_id), True)
    run_anchoring_algo(BR_INDEX_MEM, read_id, k_value, target_path, read_path, TIDY_ANCHOR_PATH[BR_INDEX_MEM].format(read_id), True)

def runtime_summary(number_of_reads, input_folder='benchmarks/'):
    times = []
    for root, dirs, files in os.walk(input_folder):
            for dir in dirs:
                with open(f'{input_folder}dir/readall.txt') as f:
                    time = re.findall(r"\d+.\d+", f.readline())[0]
            times.append(float(time))

    return [t/number_of_reads for t in times]

def main():
    #run the anchoring algos
    anchors_only('data/ecoli.fasta', 15)
    

if __name__ == '__main__':
    main()